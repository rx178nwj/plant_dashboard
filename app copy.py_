# plant_dashboard/app.py

import asyncio, logging, threading, time, json, uuid
from functools import wraps
from queue import Queue
from flask import Flask, Response, render_template, jsonify, request
import config, device_manager as dm
from ble_manager import PlantDeviceBLE, scan_devices as ble_scan, get_switchbot_adv_data
from database import init_db
import httpx

# (中略: 認証、バックグラウンド処理などは変更なし)
# ...
logging.basicConfig(level=config.LOG_LEVEL, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', handlers=[logging.FileHandler(config.LOG_FILE_PATH), logging.StreamHandler()])
logger = logging.getLogger(__name__)
app = Flask(__name__)
app.config.from_object(config)
sse_queue = Queue()
def check_auth(username, password): return username == app.config['BASIC_AUTH_USERNAME'] and password == app.config['BASIC_AUTH_PASSWORD']
def authenticate(): return Response('Could not verify your access level for that URL.\nYou have to login with proper credentials', 401, {'WWW-Authenticate': 'Basic realm="Login Required"'})
def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth = request.authorization
        if not auth or not check_auth(auth.username, auth.password): return authenticate()
        return f(*args, **kwargs)
    return decorated
async def data_collection_loop():
    logger.info("Starting data collection loop...")
    plant_sensor_connections = {}
    while True:
        devices_in_db = dm.load_devices_from_db()
        if not devices_in_db: await asyncio.sleep(config.DATA_FETCH_INTERVAL); continue
        for dev_id, device_details in devices_in_db.items():
            device_type = device_details.get('device_type'); mac_address = device_details.get('mac_address'); sensor_data = None
            try:
                if device_type == 'plant_sensor':
                    if dev_id not in plant_sensor_connections: plant_sensor_connections[dev_id] = PlantDeviceBLE(mac_address, dev_id)
                    ble_device = plant_sensor_connections[dev_id]
                    if await ble_device.ensure_connection(): sensor_data = await ble_device.get_sensor_data()
                elif device_type.startswith('switchbot_'): sensor_data = await get_switchbot_adv_data(mac_address)
                if sensor_data:
                    dm.save_sensor_data(dev_id, sensor_data)
                    dm.update_device_status(dev_id, 'connected', sensor_data.get('battery_level'))
                else: dm.update_device_status(dev_id, 'disconnected')
            except Exception as e: logger.error(f"Unhandled error in data collection for {dev_id}: {e}"); dm.update_device_status(dev_id, 'error')
            sse_queue.put(dm.get_all_devices())
        await asyncio.sleep(config.DATA_FETCH_INTERVAL)
def run_async_loop(): asyncio.run(data_collection_loop())

@app.context_processor
def inject_nav():
    return dict(nav_items=[
        {'url': 'dashboard', 'icon': 'bi-grid-fill', 'text': 'Dashboard'},
        {'url': 'management', 'icon': 'bi-sliders', 'text': 'Management'}, # ProfilesをManagementに変更
        {'url': 'devices', 'icon': 'bi-hdd-stack-fill', 'text': 'Devices'},
        {'url': 'plants', 'icon': 'bi-book-half', 'text': 'Plant Library'}
    ])

# (Dashboard, Stream, Devices, Plantsページは変更なし)
@app.route('/')
@requires_auth
def dashboard():
    """メインダッシュボード"""
    conn = dm.get_db_connection()
    # グラフ表示対象のSwitchBotデバイスのみを取得
    switchbots = conn.execute("SELECT device_id, device_name FROM devices WHERE device_type LIKE 'switchbot_%'").fetchall()
    conn.close()
    return render_template('dashboard.html', 
                           devices=dm.get_all_devices(), 
                           switchbots_for_chart=switchbots,
                           active_page='dashboard')

@app.route('/api/history/<device_id>')
@requires_auth
def api_history(device_id):
    """指定されたデバイスと期間の履歴データを返すAPI"""
    period = request.args.get('period', '24h')
    period_map = {
        '12h': "'-12 hours'", '24h': "'-1 day'", '7d': "'-7 days'",
        '30d': "'-1 month'", '1y': "'-1 year'"
    }
    time_modifier = period_map.get(period, "'-1 day'")
    conn = dm.get_db_connection()
    query = f"SELECT timestamp, temperature, humidity FROM sensor_data WHERE device_id = ? AND timestamp > datetime('now', {time_modifier}) ORDER BY timestamp ASC"
    history = conn.execute(query, (device_id,)).fetchall()
    conn.close()
    return jsonify([dict(row) for row in history])

# --- ▼▼▼ このルートが404エラーの原因です ▼▼▼ ---
@app.route('/stream')
@requires_auth
def stream():
    def event_stream():
        while True:
            data = sse_queue.get()
            yield f"data: {json.dumps(data)}\n\n"
    return Response(event_stream(), mimetype='text/event-stream')
# --- ▲▲▲ ここまで ▲▲▲ ---

@app.route('/devices')
@requires_auth
def devices():
    conn = dm.get_db_connection()
    registered_devices = conn.execute('SELECT * FROM devices ORDER BY device_name').fetchall()
    conn.close()
    return render_template('devices.html', registered_devices=registered_devices, active_page='devices')
@app.route('/plants')
@requires_auth
def plants(): return render_template('plants.html', active_page='plants')

@app.route('/api/plants/lookup', methods=['POST'])
@requires_auth
def api_plant_lookup():
    data = request.json
    plant_name = f"{data.get('genus', '')} {data.get('species', '')} {data.get('variety', '')}".strip()
    if not plant_name: return jsonify({'success': False, 'message': 'Plant name is required.'}), 400

    async def get_lookup_data():
        prompt = f"""
        Search the web to find the most accurate and detailed information for the plant '{plant_name}'.
        Identify a single, representative native region. Provide monthly climate data for that region.
        Also, provide distinct temperature ranges for its fast growth, slow growth, hot dormancy, and cold dormancy periods.
        Provide separate watering instructions for each of these four periods.
        I need all information in a structured JSON format. If a value is unknown, use null. All temperatures are in Celsius.
        
        JSON format: {{
          "origin_country": "string", "origin_region": "string",
          "monthly_temps": {{ "jan": {{"avg": integer, "high": integer, "low": integer}}, ...11 more months... }},
          "growing_fast_temp_high": integer, "growing_fast_temp_low": integer,
          "growing_slow_temp_high": integer, "growing_slow_temp_low": integer,
          "hot_dormancy_temp_high": integer, "hot_dormancy_temp_low": integer,
          "cold_dormancy_temp_high": integer, "cold_dormancy_temp_low": integer,
          "lethal_temp_high": integer, "lethal_temp_low": integer,
          "watering_growing": "string", "watering_slow_growing": "string",
          "watering_hot_dormancy": "string", "watering_cold_dormancy": "string",
          "image_url": "string (a direct URL to a representative image)"
        }}
        """
        api_key = app.config['GEMINI_API_KEY']
        if not api_key or api_key == 'YOUR_API_KEY_HERE': raise ValueError("Gemini API key is not configured")
        api_url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key={api_key}"
        payload = {"contents": [{"parts": [{"text": prompt}]}], "generationConfig": {"response_mime_type": "application/json"}}
        async with httpx.AsyncClient(timeout=45.0) as client:
            response = await client.post(api_url, json=payload)
            response.raise_for_status()
            result = response.json()
            try:
                content = result['candidates'][0]['content']['parts'][0]['text']
                if content.strip().startswith("```json"): content = content.strip()[7:-3]
                return json.loads(content)
            except (KeyError, IndexError):
                raise ValueError("Could not parse Gemini API response.")
    try:
        response_data = asyncio.run(get_lookup_data())
        return jsonify({'success': True, 'data': response_data})
    except Exception as e:
        logger.error(f"Plant lookup failed: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/plants', methods=['GET', 'POST'])
@requires_auth
def api_plants():
    conn = dm.get_db_connection()
    if request.method == 'POST':
        data = request.json
        plant_id = data.get('plant_id') or f"plant_{uuid.uuid4().hex[:8]}"
        monthly_temps_str = json.dumps(data.get('monthly_temps'))
        
        cursor = conn.cursor()
        cursor.execute("SELECT plant_id FROM plants WHERE plant_id = ?", (plant_id,))
        exists = cursor.fetchone()
        
        if exists: # Update
            cursor.execute("""
                UPDATE plants SET genus=?, species=?, variety=?, image_url=?, origin_country=?, origin_region=?, monthly_temps_json=?, growing_fast_temp_high=?, growing_fast_temp_low=?, growing_slow_temp_high=?, growing_slow_temp_low=?, hot_dormancy_temp_high=?, hot_dormancy_temp_low=?, cold_dormancy_temp_high=?, cold_dormancy_temp_low=?, lethal_temp_high=?, lethal_temp_low=?, watering_growing=?, watering_slow_growing=?, watering_hot_dormancy=?, watering_cold_dormancy=?
                WHERE plant_id=?
            """, (data['genus'], data['species'], data['variety'], data['image_url'], data['origin_country'], data['origin_region'], monthly_temps_str, data['growing_fast_temp_high'], data['growing_fast_temp_low'], data['growing_slow_temp_high'], data['growing_slow_temp_low'], data['hot_dormancy_temp_high'], data['hot_dormancy_temp_low'], data['cold_dormancy_temp_high'], data['cold_dormancy_temp_low'], data['lethal_temp_high'], data['lethal_temp_low'], data['watering_growing'], data['watering_slow_growing'], data['watering_hot_dormancy'], data['watering_cold_dormancy'], plant_id))
        else: # Insert
            cursor.execute("""
                INSERT INTO plants (plant_id, genus, species, variety, image_url, origin_country, origin_region, monthly_temps_json, growing_fast_temp_high, growing_fast_temp_low, growing_slow_temp_high, growing_slow_temp_low, hot_dormancy_temp_high, hot_dormancy_temp_low, cold_dormancy_temp_high, cold_dormancy_temp_low, lethal_temp_high, lethal_temp_low, watering_growing, watering_slow_growing, watering_hot_dormancy, watering_cold_dormancy)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (plant_id, data['genus'], data['species'], data['variety'], data['image_url'], data['origin_country'], data['origin_region'], monthly_temps_str, data['growing_fast_temp_high'], data['growing_fast_temp_low'], data['growing_slow_temp_high'], data['growing_slow_temp_low'], data['hot_dormancy_temp_high'], data['hot_dormancy_temp_low'], data['cold_dormancy_temp_high'], data['cold_dormancy_temp_low'], data['lethal_temp_high'], data['lethal_temp_low'], data['watering_growing'], data['watering_slow_growing'], data['watering_hot_dormancy'], data['watering_cold_dormancy']))
        
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'plant_id': plant_id})

    # GET request
    plants_list = conn.execute("SELECT * FROM plants ORDER BY genus, species").fetchall()
    conn.close()
    results = []
    for row in plants_list:
        plant_dict = dict(row)
        if plant_dict.get('monthly_temps_json'):
            plant_dict['monthly_temps'] = json.loads(plant_dict['monthly_temps_json'])
        results.append(plant_dict)
    return jsonify(results)

@app.route('/management')
@requires_auth
def management():
    """新しい植物管理ページ"""
    conn = dm.get_db_connection()
    # 割り当て可能な各種リストを取得
    managed_plants = conn.execute("SELECT * FROM managed_plants").fetchall()
    plant_sensors = conn.execute("SELECT device_id, device_name FROM devices WHERE device_type = 'plant_sensor'").fetchall()
    switchbots = conn.execute("SELECT device_id, device_name FROM devices WHERE device_type LIKE 'switchbot_%'").fetchall()
    plant_library = conn.execute("SELECT plant_id, genus, species, variety FROM plants").fetchall()
    conn.close()
    
    return render_template('management.html', 
                           managed_plants=managed_plants,
                           plant_sensors=plant_sensors,
                           switchbots=switchbots,
                           plant_library=plant_library,
                           active_page='management')

@app.route('/api/managed-plants', methods=['GET', 'POST'])
@requires_auth
def api_managed_plants():
    conn = dm.get_db_connection()
    if request.method == 'POST':
        data = request.json
        managed_plant_id = data.get('managed_plant_id') or f"mp_{uuid.uuid4().hex[:8]}"
        
        cursor = conn.cursor()
        cursor.execute("SELECT managed_plant_id FROM managed_plants WHERE managed_plant_id = ?", (managed_plant_id,))
        exists = cursor.fetchone()

        if exists: # Update
            cursor.execute("""
                UPDATE managed_plants SET plant_name=?, library_plant_id=?, assigned_plant_sensor_id=?, assigned_switchbot_id=?
                WHERE managed_plant_id=?
            """, (data['plant_name'], data['library_plant_id'], data['assigned_plant_sensor_id'], data['assigned_switchbot_id'], managed_plant_id))
        else: # Insert
            cursor.execute("""
                INSERT INTO managed_plants (managed_plant_id, plant_name, library_plant_id, assigned_plant_sensor_id, assigned_switchbot_id)
                VALUES (?, ?, ?, ?, ?)
            """, (managed_plant_id, data['plant_name'], data['library_plant_id'], data['assigned_plant_sensor_id'], data['assigned_switchbot_id']))
        
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'managed_plant_id': managed_plant_id})

    # GET request
    plants_list = conn.execute("SELECT * FROM managed_plants").fetchall()
    conn.close()
    return jsonify([dict(row) for row in plants_list])

# (他のAPIとCLIコマンドは変更なし)
# ...
@app.cli.command('init-db')
def init_db_command(): init_db()
if __name__ == '__main__':
    init_db()
    bg_thread = threading.Thread(target=run_async_loop, daemon=True)
    bg_thread.start()
    app.run(host='0.0.0.0', port=8000, debug=False)